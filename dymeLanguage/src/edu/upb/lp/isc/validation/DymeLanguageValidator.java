/* 
 * generated by Xtext 2.26.0
 */
package edu.upb.lp.isc.validation;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

import edu.upb.lp.isc.dymeLanguage.Asignacion;
import edu.upb.lp.isc.dymeLanguage.CalistoMapTipo;
import edu.upb.lp.isc.dymeLanguage.CalistoMapValor;
import edu.upb.lp.isc.dymeLanguage.Constante;
import edu.upb.lp.isc.dymeLanguage.Declaracion;
import edu.upb.lp.isc.dymeLanguage.DymeLanguagePackage;
import edu.upb.lp.isc.dymeLanguage.Estrella;
import edu.upb.lp.isc.dymeLanguage.EstrellaFugazMeteoro;
import edu.upb.lp.isc.dymeLanguage.ExprAritmetica;
import edu.upb.lp.isc.dymeLanguage.ExprComparacion;
import edu.upb.lp.isc.dymeLanguage.ExprConcatenacion;
import edu.upb.lp.isc.dymeLanguage.ExprLogica;
import edu.upb.lp.isc.dymeLanguage.ExprLogicaOperadores;
import edu.upb.lp.isc.dymeLanguage.ExprMapOperaciones;
import edu.upb.lp.isc.dymeLanguage.Expresion;
import edu.upb.lp.isc.dymeLanguage.Funcion;
import edu.upb.lp.isc.dymeLanguage.Instrucciones;
import edu.upb.lp.isc.dymeLanguage.LlamadoFunc;
import edu.upb.lp.isc.dymeLanguage.LlamadoMapa;
import edu.upb.lp.isc.dymeLanguage.MapAdd;
import edu.upb.lp.isc.dymeLanguage.MapRemove;
import edu.upb.lp.isc.dymeLanguage.Objeto;
import edu.upb.lp.isc.dymeLanguage.Param;
import edu.upb.lp.isc.dymeLanguage.Planeta;
import edu.upb.lp.isc.dymeLanguage.PolvoEstelar;
import edu.upb.lp.isc.dymeLanguage.Primitivo;
import edu.upb.lp.isc.dymeLanguage.Print;
import edu.upb.lp.isc.dymeLanguage.TipoFuncionOrdenSuperior;
import edu.upb.lp.isc.dymeLanguage.Valor;
import edu.upb.lp.isc.dymeLanguage.XOR;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class DymeLanguageValidator extends AbstractDymeLanguageValidator {
		
	public String obtenerTipoInstruccion(Instrucciones instr) {
		if (instr instanceof Valor) {
			Valor val = (Valor) instr;
			if (val instanceof Expresion) {
				Expresion expr = (Expresion) val;
				if (expr instanceof ExprConcatenacion) {
					ExprConcatenacion exprCon = (ExprConcatenacion) expr;
					return (obtenerTipoExprConcat(exprCon));
				} else if (expr instanceof ExprAritmetica) {
					ExprAritmetica exprAr = (ExprAritmetica) expr;
					return (obtenerTipoExprArit(exprAr));
				} else if (expr instanceof ExprLogica) {
					ExprLogica exprLog = (ExprLogica) expr;
					return (obtenerTipoExprLog(exprLog));
				} else if (expr instanceof ExprComparacion) {
					return "Luna";
				} else if (expr instanceof LlamadoFunc) {
					return obtenerTipoLlamadoFunc((LlamadoFunc) expr);
				} else if (expr instanceof EstrellaFugazMeteoro) {
					return obtenerTipoInstruccion(((EstrellaFugazMeteoro) expr).getEstrellaFugazRes());
				} else if (val instanceof Constante) {
					Declaracion dec = ((Constante) val).getNombre();
					if (dec instanceof Asignacion) {
						return obtenerTipoAsignacion((Asignacion) dec);
					} else if (dec instanceof Funcion) {
						return obtenerTipoFuncion((Funcion) dec);
					} else if (dec instanceof Param) {
						return obtenerTipoParam((Param) dec);
					}
				}else if(val instanceof LlamadoMapa) {
					LlamadoMapa llamMapa = (LlamadoMapa) val;
					
					Asignacion mapAsig = (Asignacion) llamMapa.getDecID();
					if(mapAsig.isTipoInferido()) {
						return obtenerTipoFuncionOrdenSuperior(((CalistoMapTipo) mapAsig.getTipoClass()).getTipoDer());
					}else {
						return obtenerTipoInstruccion( ((CalistoMapValor) mapAsig.getValorAsig()).getValue().get(0) );
					}
					
				}
			} else if (val instanceof CalistoMapValor) {
				return obtenerTipoCalistoMapValor((CalistoMapValor) val);
			} else if (val instanceof ExprMapOperaciones) {
				ExprMapOperaciones exprMapOp = (ExprMapOperaciones) val;
				
				if(exprMapOp instanceof MapAdd) {
					return obtenerTipoFuncionOrdenSuperior( ((Asignacion) ((Declaracion) ((MapAdd) val).getMapConst().getNombre())).getTipoClass() );
				}else if(exprMapOp instanceof MapRemove) {

					return obtenerTipoFuncionOrdenSuperior( ((Asignacion) ((Declaracion) ((MapRemove) val).getMapConst().getNombre())).getTipoClass() );
				}else return "ErrorType";
			}
		}

		return "ErrorType";
	}
	
	public String obtenerTipoFuncionOrdenSuperior(TipoFuncionOrdenSuperior tipo) {
		String returnTipo = "";
		if(tipo instanceof Objeto ) {
			returnTipo = obtenerTipoObjetoInstancia((Objeto) tipo) ;
		}else if (tipo instanceof TipoFuncionOrdenSuperior) {
			TipoFuncionOrdenSuperior tipOrdSup = (TipoFuncionOrdenSuperior) tipo;

			for(int i = 0; i < tipOrdSup.getParamFunc().size(); i++) {
				returnTipo += obtenerTipoFuncionOrdenSuperior(tipOrdSup.getParamFunc().get(i));
				if(i != tipOrdSup.getParamFunc().size()-1) returnTipo += " $ ";
			}
			
			if(tipOrdSup.getParamFunc().size() != 1) returnTipo = ("("+ returnTipo +")");
			
		//returnTipo = ("("+ returnTipo +")");
		}else return "ErrorType";
		
		if(tipo.isReturnTipoFunc()) {
			returnTipo += " -> ";
			TipoFuncionOrdenSuperior returnReturnTipo = tipo.getReturnFunc();
			if(returnReturnTipo instanceof Primitivo && !returnReturnTipo.isReturnTipoFunc()) {
				returnTipo += obtenerTipoFuncionOrdenSuperior((Primitivo) returnReturnTipo);
			}else if(returnReturnTipo instanceof TipoFuncionOrdenSuperior) {
				returnTipo += ("(" + obtenerTipoFuncionOrdenSuperior(returnReturnTipo) + ")");
			}
		}
		return returnTipo;
	}
	
	public String obtenerTipoPrimitivo(Primitivo prim) {
		return prim.getTipo();
	}
	
	public String obtenerTipoCalistoMap(CalistoMapTipo cali) {
		return "Calisto["+cali.getTipoIzq().getTipo() + " $ " + cali.getTipoDer().getTipo()+"]";
	}
	
	public String obtenerTipoObjetoInstancia(Objeto obj) {
		if(obj instanceof Primitivo) {
			return obtenerTipoPrimitivo((Primitivo) obj);
		}else if(obj instanceof CalistoMapTipo) {
			return obtenerTipoCalistoMap((CalistoMapTipo) obj);
		}else return "ErrorType";
	}
	
	public String obtenerTipoCalistoMapValor(CalistoMapValor calisVal) {
		if(calisVal.getKey().size() > 0) {
			return "Calisto[" + obtenerTipoInstruccion(calisVal.getKey().get(0)) + " $ " + obtenerTipoInstruccion(calisVal.getValue().get(0))+"]";
		}else {
			return "ErrorType";
		}
	}
	
	
	public boolean ValorContieneRecursividad(Valor val, String ID) throws FuncionAsConstException, ConstanteAsLlamadoFuncException {
		if(val instanceof Expresion) {
			Expresion expr = (Expresion) val;
			if(expr instanceof LlamadoFunc) {
				Declaracion decal = ((LlamadoFunc) expr).getFuncionID();
				if(decal instanceof Asignacion) {
					throw new ConstanteAsLlamadoFuncException("CONST_AS_LLAMADOFUNC", "Using constant as function call", decal);
				}else if(decal instanceof Funcion) {
					return ((Funcion) decal).getName().equals(ID);
				}else if(decal instanceof Print) {
					return ValorContieneRecursividad(((Print) decal).getVal(), ID);
				}else if(decal instanceof Param) {
					if(!((Param) decal).isTipoRetorno()) {
						throw new ConstanteAsLlamadoFuncException("CONST_AS_LLAMADOFUNC", "Using constant as function call", decal);
					}
				}
			}else if(expr instanceof ExprConcatenacion) {
				ExprConcatenacion exprConc = (ExprConcatenacion) expr;
				for(int i = 0; i < exprConc.getExprCon().size(); i++) {
					if(ValorContieneRecursividad(exprConc.getExprCon().get(i), ID)) return true;
				}
				return false;
			}else if(expr instanceof ExprAritmetica) {
				ExprAritmetica exprArit = (ExprAritmetica) expr;
				for(int i = 0; i < exprArit.getExprAr().size(); i++) {
					if(ValorContieneRecursividad(exprArit.getExprAr().get(i), ID)) return true;
				}
				return false;
			}else if(expr instanceof ExprComparacion) {
				ExprComparacion exprComp = (ExprComparacion) expr;
				return ValorContieneRecursividad(exprComp.getExprComIzq(), ID) || ValorContieneRecursividad(exprComp.getExprComDer(), ID);
			}else if(expr instanceof ExprLogica) {
				ExprLogica exprLog = (ExprLogica) expr;
				if(exprLog.getExprLog() instanceof ExprLogicaOperadores) {
					ExprLogicaOperadores exprLogOp = (ExprLogicaOperadores) exprLog.getExprLog();
					for(int i = 0; i < exprLogOp.getExprLogs().size(); i++) {
						if(ValorContieneRecursividad(exprLogOp.getExprLogs().get(i), ID)) return true;
					}
					return false;
				}else if(exprLog.getExprLog() instanceof XOR) {
					XOR exprXOR = (XOR) exprLog.getExprLog();
					return ValorContieneRecursividad(exprXOR.getExprLogIzq(), ID) || ValorContieneRecursividad(exprXOR.getExprLogDer(), ID);
				}else if(exprLog.getExprLog() instanceof ExprComparacion) {
					//TODO puede fallar?
					//return ValorContieneRecursividad((Valor) exprLog.getExprLog(), ID);
					return false;
				}
				return false;
			}else if(expr instanceof EstrellaFugazMeteoro) {
				System.out.println("estrella");
				EstrellaFugazMeteoro exprComp = (EstrellaFugazMeteoro) expr;
				return ValorContieneRecursividad(exprComp.getEstrellaFugazRes(), ID) || ValorContieneRecursividad(exprComp.getMeteoroRes(), ID);
			}else if(val instanceof Constante) {
				Constante constan = (Constante) val;
				System.out.println("Constante: " + constan.getNombre());
				if(constan.getNombre() instanceof Funcion) {
					throw new FuncionAsConstException("FUNCION_AS_VALUE", "Using Funcion as Value", constan.getNombre());
				}else if(constan.getNombre() instanceof Param) {
					Param paramConst = (Param) constan.getNombre();
					//System.out.println(paramConst.getName() + " Es parametro");
					if(paramConst.isTipoRetorno()) {
						//System.out.println("Tiene tipo de retorno");
						throw new FuncionAsConstException("FUNCION_AS_VALUE", "Using Funcion as Value", constan.getNombre());
					}else {
						//System.out.println("NO Tiene tipo de retorno");
					}
				}
			}
			return false;
		}
		
		return false;
	}
	
	public boolean declaracionContieneRecursividad(Declaracion decl, String FuncID) throws FuncionAsConstException, ConstanteAsLlamadoFuncException {
		if(decl instanceof Asignacion) {
			return ValorContieneRecursividad(((Asignacion) decl).getValorAsig(), FuncID);
		}else if(decl instanceof Funcion) {
			return funcionTieneRecursividad(((Funcion) decl), FuncID);
		}
		return false;
	}
	
	public boolean funcionTieneRecursividad(Funcion func, String ID) throws FuncionAsConstException, ConstanteAsLlamadoFuncException {
		String FuncID;
		if(ID.equals("")) FuncID = func.getName();
		else FuncID = ID;
		
		System.out.println("Funcion: " + FuncID);
		
		for(int i = 0; i < func.getDeclar().size(); i++) {
			if(func.getDeclar().get(i) instanceof Declaracion) {
				if(declaracionContieneRecursividad((Declaracion) func.getDeclar().get(i), FuncID)) return true;
				
			}else if(func.getDeclar().get(i) instanceof Print) {
				if(ValorContieneRecursividad(((Print) func.getDeclar().get(i)).getVal(), FuncID)) return true;
			}
		}
		
		if(ValorContieneRecursividad(func.getVal(), FuncID)) return true;
		
		return false;
	}
	
	public String obtenerTipoFuncion(Funcion func) {
		String returnFuncTipo = "";
		
		for(int i = 0; i < func.getParam().size(); i++) {
			returnFuncTipo += obtenerTipoParam(func.getParam().get(i));
			if(i != func.getParam().size()-1) returnFuncTipo += " $ ";
		}
		
		if(func.getParam().size() != 1) returnFuncTipo = ("("+ returnFuncTipo +")");

		
		returnFuncTipo += " -> ";

		if(func.isTipoInferido()) {
			returnFuncTipo += obtenerTipoFuncionOrdenSuperior(func.getTipoClass());
		}else {
			try {
			if(!funcionTieneRecursividad(func, func.getName())) {
				returnFuncTipo += obtenerTipoInstruccion(func.getVal());
			}
			}catch(FuncionAsConstException e) {
				return "ErrorType";
			}catch(ConstanteAsLlamadoFuncException e) {
				return "ErrorType";
			}
		}
		
		return returnFuncTipo;
	}
	
	
	
	public String obtenerTipoAsignacion(Asignacion asg) {
		if(asg.isTipoInferido()) {
			return obtenerTipoFuncionOrdenSuperior(asg.getTipoClass());
		}else {
			return obtenerTipoInstruccion(asg.getValorAsig());
		}
	}
	
	public String obtenerTipoParam(Param param) {
		String paramTipo = "";
		for(int i = 0; i < param.getParam().size(); i++) {
			paramTipo += obtenerTipoFuncionOrdenSuperior(param.getParam().get(i));
			if(i != param.getParam().size()-1) paramTipo += " $ ";
		}
		if(param.getParam().size() != 1) paramTipo = "("+paramTipo+")";
		if(param.isTipoRetorno()) {
			paramTipo += " -> ";
			paramTipo += param.getReturnTipo().getTipo(); 	
		}
		return paramTipo;
	}
	
	public String obtenerTipoExprConcat(ExprConcatenacion expr) {
		if(expr instanceof Estrella) {
			return "Estrella";
		}else {
			return "Constelacion";
		}
	}
	
	public String obtenerTipoExprArit(ExprAritmetica expr) {
		if(expr instanceof Planeta) {
			return "Planeta";
		}else if(expr instanceof PolvoEstelar) {
			return "PolvoEstelar";
		}else {
			String tipoTemp = "Planeta";
			for (int i = 0; i < expr.getExprAr().size(); i++) {
				tipoTemp = obtenerTipoInstruccion(expr.getExprAr().get(i));
				if(tipoTemp.equals("PolvoEstelar")) tipoTemp = "PolvoEstelar";
				else if(!tipoTemp.equals("PolvoEstelar") && !tipoTemp.equals("Cometa") && !tipoTemp.equals("Planeta")) {
					return "ErrorType";
				}
			}
			return tipoTemp;
		}
	}
	
	public String obtenerTipoExprLog(ExprLogica expr) {
		return "Luna";
		/*
		if(expr.getExprLog() instanceof Luna) {
			return "Luna";
		}else if(expr.getExprLog() instanceof ExprLogicaOperadores){
			String tipoTemp = "Luna";
			return obtenerTipoInstruccion(((ExprLogicaOperadores) expr.getExprLog()).getExprLog().get(0));
		}else if (expr.getExprLog() instanceof ExprComparacion) {
			return "Luna";
		}else if (expr.getExprLog() instanceof XOR) {
			return "Luna";
		}else return "ErrorType";
		*/
	}
	
	
	public String obtenerTipoLlamadoFunc(LlamadoFunc llf) {
		
		Declaracion decllf = llf.getFuncionID();
		
		if(decllf instanceof Funcion) {
			
			Funcion funcActual = (Funcion) llf.getFuncionID();
			if(funcActual.isTipoInferido()) {
				return funcActual.getTipoClass().getTipo();
			}else {
				try {
				if(!funcionTieneRecursividad(funcActual, funcActual.getName())) {
					return obtenerTipoInstruccion(funcActual.getVal());
				}else return "ErrorType";
				
				}catch(FuncionAsConstException e) {
					return "ErrorType";
				}catch(ConstanteAsLlamadoFuncException e) {
					return "ErrorType";
				}
			}
			
		}else if(decllf instanceof Param) {
			Param paramllf = (Param) decllf;
			if(paramllf.isTipoRetorno()) {
				return paramllf.getReturnTipo().getTipo();
			}else {
				return obtenerTipoParam(paramllf);
			}
		}else if(decllf instanceof Asignacion) {
			Asignacion asgllf = (Asignacion)decllf;
			
			if(asgllf.isTipoInferido()) {
				// deberia retornar solo el valor despues de la flecha si es llf
				return obtenerTipoFuncionOrdenSuperior(asgllf.getTipoClass());
			}else {
				return obtenerTipoInstruccion(asgllf.getValorAsig());
			}
		}else return "ErrorType";
	}
	
	public String obtenerTipoConstante(Constante cons) {
		if(cons.getNombre() instanceof Param) {
			return obtenerTipoInstruccion(((Param) cons.getNombre()));
		}else if(cons.getNombre() instanceof Asignacion) {
			Asignacion consAsg = (Asignacion) cons.getNombre();
			if(consAsg.isTipoInferido()) {
				return obtenerTipoFuncionOrdenSuperior(consAsg.getTipoClass());
			}else {
				Valor consAsgValor = consAsg.getValorAsig();
				String argTipo = obtenerTipoInstruccion(consAsgValor);
				return argTipo;
			}
			
		}else return "ErrorType";
		
	}
	
	@Check
	public void verificarNumeroParametrosLLamadoFunc(LlamadoFunc llf) {
		if(llf.getFuncionID() instanceof Funcion) {		
			Funcion funcActual = (Funcion) llf.getFuncionID();
			if(llf.getArgs().size() != funcActual.getParam().size()) {
				error("Numero de Argumentos no valido: " + llf.getArgs().size(), DymeLanguagePackage.Literals.LLAMADO_FUNC__ARGS.getEOpposite());
			}
			for (int i = 0; i < llf.getArgs().size(); i++) {
				String argumento = obtenerTipoInstruccion(llf.getArgs().get(i));
				String parametro = obtenerTipoParam(funcActual.getParam().get(i));
				//System.out.println("argumento: " + argumento + " parametro: " + parametro);
				if(!argumento.equals(parametro)) {
					error("Argumento " + (i+1) + " no valido '"+ argumento + "' para el tipo de parametro '" + parametro + "'", DymeLanguagePackage.Literals.LLAMADO_FUNC__ARGS.getEOpposite());
				}
			}
			
		}else if (llf.getFuncionID() instanceof Param) {
			Param param = (Param) llf.getFuncionID();
			if(llf.getArgs().size() != param.getParam().size()) {
				error("Numero de Argumentos no valido: " + llf.getArgs().size(), DymeLanguagePackage.Literals.LLAMADO_FUNC__ARGS.getEOpposite());
			}
			for (int i = 0; i < llf.getArgs().size(); i++) {
				String argumento = obtenerTipoInstruccion(llf.getArgs().get(i));
				String parametro = obtenerTipoFuncionOrdenSuperior(param.getParam().get(i));
				
				if(!argumento.equals(parametro)) {
					error("Argumento " + (i+1) + " no valido '"+ argumento + "' para el tipo de parametro '" + parametro + "'", DymeLanguagePackage.Literals.LLAMADO_FUNC__ARGS.getEOpposite());
				}
				//System.out.println("Tipo Parametros (lo que ponemos) "+parametro);
				//System.out.println("Tipo Argumento (lo que deberiamos) "+argumento);
			}
			
		}else if(llf.getFuncionID() instanceof Asignacion) {
			
		}
		
	}

	@Check
	public void verificarTiposExprArit(ExprAritmetica exprAr) {
		if(!(exprAr instanceof Planeta | exprAr instanceof PolvoEstelar) && exprAr.getExprAr().size() <= 1 ) {
			error("Se necesitan minimo 2 expresiones numericas", DymeLanguagePackage.Literals.EXPR_ARITMETICA__EXPR_AR.getEOpposite());
		}else {
			for( int i = 0; i < exprAr.getExprAr().size(); i++) {
				String exprTipo = obtenerTipoInstruccion(exprAr.getExprAr().get(i));
				if(!(exprTipo.equals("Planeta") | exprTipo.equals("PolvoEstelar"))) {
					error("Discordancia de tipos", DymeLanguagePackage.Literals.EXPR_ARITMETICA__EXPR_AR.getEOpposite());
					break;
				}
			}
		}
	}
	
	@Check
	public void verificarTiposExprLog(ExprLogica exprLog) {
		if(exprLog.getExprLog() instanceof ExprLogicaOperadores ) {
			ExprLogicaOperadores exprLogOp = (ExprLogicaOperadores) exprLog.getExprLog();
			
			if(exprLogOp.getExprLogs().size() <= 1 ) {
				error("Se necesitan minimo 2 expresiones logicas", DymeLanguagePackage.Literals.EXPR_LOGICA__EXPR_LOG.getEOpposite());
			}else {
				for(int i = 0; i < exprLogOp.getExprLogs().size(); i++) {
					if(!obtenerTipoInstruccion(exprLogOp.getExprLogs().get(i)).equals("Luna")) {
						error("Discordancia de tipos", DymeLanguagePackage.Literals.EXPR_LOGICA_OPERADORES__EXPR_LOGS.getEOpposite());
						break;
					}
				}
			}
		}else if(exprLog.getExprLog() instanceof XOR) {
			XOR xorExpr = (XOR) exprLog.getExprLog();
			String izqTipo = obtenerTipoInstruccion(xorExpr.getExprLogIzq());
			String derTipo = obtenerTipoInstruccion(xorExpr.getExprLogDer());
			if(!(izqTipo.equals("Luna") && derTipo.equals("Luna"))){
				error("Discordancia de tipos", DymeLanguagePackage.Literals.XOR__EXPR_LOG_IZQ.getEOpposite());
			}
		}
	}
	
	public boolean argumentosConParametrosCorrecto(EList<Param> paramList, LlamadoFunc llf) {
		for (int i = 0; i < llf.getArgs().size(); i++) {
			String argumento = obtenerTipoInstruccion(llf.getArgs().get(i));
			String parametro = obtenerTipoParam(paramList.get(i));
			//System.out.println("argumento: " + argumento + " parametro: " + parametro);
			if(!argumento.equals(parametro)) return false;
		}
		return true;
	}
	
	
	@Check
	public void verificarTipoEnCondicionEstrellaFugazmeteoro(EstrellaFugazMeteoro estFugMet) {
		String exprCond = obtenerTipoInstruccion(estFugMet.getExprLogCondicion());
		if(!exprCond.equals("Luna")) {
			error("La condicion solo puede ser una expresion logica",
					DymeLanguagePackage.Literals.ESTRELLA_FUGAZ_METEORO__EXPR_LOG_CONDICION);
		}
	}
	
	@Check
	public void verificarTipoEnEstrellaFugazmeteoro(EstrellaFugazMeteoro estFugMet) {
		String exprEstFugTipo = obtenerTipoInstruccion(estFugMet.getEstrellaFugazRes());
		String exprMeteoro = obtenerTipoInstruccion(estFugMet.getMeteoroRes());
		if(!exprEstFugTipo.equals(exprMeteoro)) {
			error("Discordancia de tipos en expresion EstrellaFugazMeteoro", DymeLanguagePackage.Literals.ESTRELLA_FUGAZ_METEORO__ESTRELLA_FUGAZ_RES.getEOpposite());
		}
	}
	
	
	@Check
	public void verificarTipoFuncion(Funcion func) {
		String tipoExprFinal= obtenerTipoInstruccion(func.getVal());
		if(func.isTipoInferido()) {
			String TipoFunc = obtenerTipoFuncionOrdenSuperior(func.getTipoClass());
			if(tipoExprFinal.startsWith("(") && tipoExprFinal.endsWith(")")) {
				tipoExprFinal = tipoExprFinal.substring(1, tipoExprFinal.length()-1);
			}
			//System.out.println("Tipo Valor inferido: " + tipoExprFinal);
			//System.out.println("Tipo Valor Definido: " + TipoFunc);
			if(!TipoFunc.equals(tipoExprFinal)) {
				error("Tipo no valido: " + tipoExprFinal, DymeLanguagePackage.Literals.FUNCION__VAL);
			}
		}else {
			try {
			if (funcionTieneRecursividad(func, func.getName())) {
				error("No puedes usar recursividad sin poner un tipo de retorno de esta funcion", DymeLanguagePackage.Literals.FUNCION__VAL.getEOpposite());
			}
			}catch(FuncionAsConstException e) {
				if(e.getDeclTrouble() instanceof Funcion) {
					Funcion funcTrouble = (Funcion) e.getDeclTrouble();
					error("No puedes usar a la funcion " + funcTrouble.getName() + " como un valor", DymeLanguagePackage.Literals.FUNCION__VAL.getEOpposite());
				}else if(e.getDeclTrouble() instanceof Param) {
					Param paramTrouble = (Param) e.getDeclTrouble();
					error("No puedes usar al parametro " + paramTrouble.getName() + " como un valor", DymeLanguagePackage.Literals.FUNCION__VAL.getEOpposite());
				}
			}catch(ConstanteAsLlamadoFuncException e) {
				if(e.getDeclTrouble() instanceof Asignacion) {
					Asignacion asigTrouble = (Asignacion) e.getDeclTrouble();
					error("No puedes llamar a la constante " + asigTrouble.getName() + " como una funcion", DymeLanguagePackage.Literals.FUNCION__VAL.getEOpposite());
				}else if(e.getDeclTrouble() instanceof Param) {
					Param paramTrouble = (Param) e.getDeclTrouble();
					error("No puedes llamar al parametro " + paramTrouble.getName() + " como una funcion", DymeLanguagePackage.Literals.FUNCION__VAL.getEOpposite());
				}
			}
		}
	}
	
	@Check
	public void verificarOInferirTipoDeExpresionEnAsignacion(Asignacion asg) {

		Valor valor = asg.getValorAsig();
		if (asg.isTipoInferido()) {
			String tipo = obtenerTipoFuncionOrdenSuperior(asg.getTipoClass());
			String exprTipo = obtenerTipoInstruccion(valor);
			if (!exprTipo.equals(tipo)) {
				error("Tipo no valido: " + exprTipo, DymeLanguagePackage.Literals.ASIGNACION__VALOR_ASIG);
			}

		}
	}
	
	@Check
	public void verificarTiposDeExprComp(ExprComparacion exprCom) {
		String exprIzqTipo = obtenerTipoInstruccion(exprCom.getExprComIzq());
		String exprDerTipo = obtenerTipoInstruccion(exprCom.getExprComDer());
		String operador = exprCom.getOperadorComp();
		/*
		System.out.println("Izq " + exprIzqTipo);
		System.out.println("Der " + exprDerTipo);
		System.out.println("op " + operador);
		*/
		if (!exprIzqTipo.equals(exprDerTipo)) {
			if (operador.equals("==") || operador.equals("~=")) {
				if ( !((exprIzqTipo.equals("Planeta") && exprDerTipo.equals("PolvoEstelar")
						|| (exprIzqTipo.equals("PolvoEstelar") && exprDerTipo.equals("Planeta"))
						|| (exprIzqTipo.equals("Constelacion") && exprDerTipo.equals("Estrella"))
						|| (exprIzqTipo.equals("Estrella") && exprDerTipo.equals("Constelacion")))) ) {
					error("Comparacion de tipos invalida",
							DymeLanguagePackage.Literals.EXPR_COMPARACION__EXPR_COM_DER.getEOpposite());
				}
			} else {
				if ( !((exprIzqTipo.equals("Planeta") && exprDerTipo.equals("PolvoEstelar")
						|| (exprIzqTipo.equals("PolvoEstelar") && exprDerTipo.equals("Planeta")))) ){
					error("Comparacion de tipos invalida",
							DymeLanguagePackage.Literals.EXPR_COMPARACION__EXPR_COM_DER.getEOpposite());
				}
			}
		} else {
			if(!(operador.equals("==") || operador.equals("~="))) {
				if(exprIzqTipo.equals("Constelacion") || exprIzqTipo.equals("Estrella")  || exprIzqTipo.equals("Luna") ) {
					error("Operador no valido para esta comparacion",
							DymeLanguagePackage.Literals.EXPR_COMPARACION__EXPR_COM_DER.getEOpposite());
				}
			}
		}
	}
	
	public boolean verficarTailRecursionExpresion(Expresion expr, String ID) {
		if(expr instanceof LlamadoFunc) {
			Declaracion declar = ((LlamadoFunc) expr).getFuncionID();
			if(declar instanceof Funcion) {
				return ((Funcion) declar).getName().equals(ID);
			}
			return false;
		}else if(expr instanceof ExprLogica) {
			ExprLogica exprLog = (ExprLogica) expr;
			if(exprLog.getExprLog() instanceof ExprLogicaOperadores) {
				ExprLogicaOperadores exprLogOp = (ExprLogicaOperadores) exprLog.getExprLog();
				for(int i = 0; i < exprLogOp.getExprLogs().size()-1; i++) {
					if(verficarTailRecursionExpresion(exprLogOp.getExprLogs().get(i), ID)) {
						return false;
					}
				}
				Expresion lastExpr = exprLogOp.getExprLogs().get(exprLogOp.getExprLogs().size()-1);
				return (verficarTailRecursionExpresion(lastExpr, ID));
			}
		}else if(expr instanceof EstrellaFugazMeteoro) {
			EstrellaFugazMeteoro estFugMet = (EstrellaFugazMeteoro) expr;
			try {
				Boolean EstrellaResTieneRecur = ValorContieneRecursividad(estFugMet.getEstrellaFugazRes(), ID);
				Boolean MeteoroResTieneRecur = ValorContieneRecursividad(estFugMet.getMeteoroRes(), ID);
				Boolean EstrellaEsTailRecursive = verficarTailRecursionExpresion(estFugMet.getEstrellaFugazRes(), ID);
				Boolean MeteoroEsTailRecursive = verficarTailRecursionExpresion(estFugMet.getMeteoroRes(), ID);
				
			return ((EstrellaResTieneRecur && EstrellaEsTailRecursive) || 
					(MeteoroResTieneRecur && MeteoroEsTailRecursive));
			}catch(FuncionAsConstException e) {
				return false;
			}catch(ConstanteAsLlamadoFuncException e) {
				return false;
			}
		}
		
		
		return false;
	}
	
	@Check
	public void verificarTailRecursionFuncion(Funcion func) {
		Valor val = func.getVal();
		if(val instanceof Expresion) {
			Boolean tailRecAnotacion = func.isGusano();
			Boolean tailRecValor = verficarTailRecursionExpresion((Expresion) val, func.getName());
			
			if(tailRecAnotacion && !tailRecValor) {
				error("Esta funcion NO es Tail Recursive",
						DymeLanguagePackage.Literals.FUNCION__GUSANO);
			}
			if(!tailRecAnotacion && tailRecValor) {
				error("Esta funcion es Tail Recursive",
						DymeLanguagePackage.Literals.FUNCION__GUSANO);
			}
		}
	}
	
	@Check
	public void verificarTiposMapaValor(CalistoMapValor calisMapVal) {
		String firstKey = obtenerTipoInstruccion(calisMapVal.getKey().get(0));
		String firstValue = obtenerTipoInstruccion(calisMapVal.getValue().get(0));
		for(int i = 0; i < calisMapVal.getKey().size(); i++) {
			if(!obtenerTipoInstruccion(calisMapVal.getKey().get(i)).equals(firstKey) ||
				!obtenerTipoInstruccion(calisMapVal.getValue().get(i)).equals(firstValue)){
				error("Discordancia de tipo en mapa",
						DymeLanguagePackage.Literals.CALISTO_MAP_VALOR__KEY.getEOpposite());
				break;
			}
		}
	}
	//TODO en la generacion de codigo verificar los operadores, ya que son diferentes
}