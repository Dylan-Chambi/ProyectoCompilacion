/*
 * generated by Xtext 2.26.0
 */
package edu.upb.lp.isc.serializer;

import com.google.inject.Inject;
import edu.upb.lp.isc.dymeLanguage.Asignacion;
import edu.upb.lp.isc.dymeLanguage.DymeLanguagePackage;
import edu.upb.lp.isc.dymeLanguage.ExprSimple;
import edu.upb.lp.isc.dymeLanguage.Funcion;
import edu.upb.lp.isc.dymeLanguage.LlamadoFunc;
import edu.upb.lp.isc.dymeLanguage.Param;
import edu.upb.lp.isc.dymeLanguage.Suma;
import edu.upb.lp.isc.services.DymeLanguageGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DymeLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DymeLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DymeLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DymeLanguagePackage.ASIGNACION:
				sequence_Asignacion(context, (Asignacion) semanticObject); 
				return; 
			case DymeLanguagePackage.EXPR_SIMPLE:
				sequence_ExprSimple(context, (ExprSimple) semanticObject); 
				return; 
			case DymeLanguagePackage.FUNCION:
				sequence_Funcion(context, (Funcion) semanticObject); 
				return; 
			case DymeLanguagePackage.LLAMADO_FUNC:
				sequence_LlamadoFunc(context, (LlamadoFunc) semanticObject); 
				return; 
			case DymeLanguagePackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case DymeLanguagePackage.SUMA:
				sequence_Suma(context, (Suma) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns Asignacion
	 *     Asignacion returns Asignacion
	 *
	 * Constraint:
	 *     (name=ID tip=Tipo? valor=Expresion)
	 * </pre>
	 */
	protected void sequence_Asignacion(ISerializationContext context, Asignacion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expresion returns ExprSimple
	 *     ExprSimple returns ExprSimple
	 *
	 * Constraint:
	 *     (x=STRING | p=Planeta)
	 * </pre>
	 */
	protected void sequence_ExprSimple(ISerializationContext context, ExprSimple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Funcion returns Funcion
	 *
	 * Constraint:
	 *     (name=ID (param+=Param param+=Param*)? instr+=Instruccion+ tip=Tipo)
	 * </pre>
	 */
	protected void sequence_Funcion(ISerializationContext context, Funcion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LlamadoFunc returns LlamadoFunc
	 *     Expresion returns LlamadoFunc
	 *
	 * Constraint:
	 *     (funcion=[Funcion|ID] (args+=Expresion args+=Expresion*)?)
	 * </pre>
	 */
	protected void sequence_LlamadoFunc(ISerializationContext context, LlamadoFunc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Param returns Param
	 *
	 * Constraint:
	 *     (name=ID tip=Tipo)
	 * </pre>
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.PARAM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.PARAM__NAME));
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.PARAM__TIP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.PARAM__TIP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParamAccess().getTipTipoParserRuleCall_2_0(), semanticObject.getTip());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expresion returns Suma
	 *     Suma returns Suma
	 *
	 * Constraint:
	 *     (izq=ExprSimple der=ExprSimple)
	 * </pre>
	 */
	protected void sequence_Suma(ISerializationContext context, Suma semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.SUMA__IZQ) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.SUMA__IZQ));
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.SUMA__DER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.SUMA__DER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumaAccess().getIzqExprSimpleParserRuleCall_0_0(), semanticObject.getIzq());
		feeder.accept(grammarAccess.getSumaAccess().getDerExprSimpleParserRuleCall_2_0(), semanticObject.getDer());
		feeder.finish();
	}
	
	
}
