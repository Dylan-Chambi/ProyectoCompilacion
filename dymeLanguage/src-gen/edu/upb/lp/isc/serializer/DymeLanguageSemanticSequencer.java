/*
 * generated by Xtext 2.26.0
 */
package edu.upb.lp.isc.serializer;

import com.google.inject.Inject;
import edu.upb.lp.isc.dymeLanguage.Asignacion;
import edu.upb.lp.isc.dymeLanguage.Constante;
import edu.upb.lp.isc.dymeLanguage.Constelacion;
import edu.upb.lp.isc.dymeLanguage.DymeLanguagePackage;
import edu.upb.lp.isc.dymeLanguage.Estrella;
import edu.upb.lp.isc.dymeLanguage.EstrellaFugazMeteoro;
import edu.upb.lp.isc.dymeLanguage.ExprAritmetica;
import edu.upb.lp.isc.dymeLanguage.ExprComparacion;
import edu.upb.lp.isc.dymeLanguage.ExprConcatenacion;
import edu.upb.lp.isc.dymeLanguage.ExprLogica;
import edu.upb.lp.isc.dymeLanguage.Funcion;
import edu.upb.lp.isc.dymeLanguage.LlamadoFunc;
import edu.upb.lp.isc.dymeLanguage.Luna;
import edu.upb.lp.isc.dymeLanguage.Param;
import edu.upb.lp.isc.dymeLanguage.Planeta;
import edu.upb.lp.isc.dymeLanguage.PolvoEstelar;
import edu.upb.lp.isc.dymeLanguage.Programa;
import edu.upb.lp.isc.dymeLanguage.Tipo;
import edu.upb.lp.isc.dymeLanguage.TipoFuncionOrdenSuperior;
import edu.upb.lp.isc.services.DymeLanguageGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DymeLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DymeLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DymeLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DymeLanguagePackage.ASIGNACION:
				sequence_Asignacion(context, (Asignacion) semanticObject); 
				return; 
			case DymeLanguagePackage.CONSTANTE:
				sequence_Constante(context, (Constante) semanticObject); 
				return; 
			case DymeLanguagePackage.CONSTELACION:
				sequence_Constelacion(context, (Constelacion) semanticObject); 
				return; 
			case DymeLanguagePackage.ESTRELLA:
				sequence_Estrella(context, (Estrella) semanticObject); 
				return; 
			case DymeLanguagePackage.ESTRELLA_FUGAZ_METEORO:
				sequence_EstrellaFugazMeteoro(context, (EstrellaFugazMeteoro) semanticObject); 
				return; 
			case DymeLanguagePackage.EXPR_ARITMETICA:
				sequence_ExprAritmetica(context, (ExprAritmetica) semanticObject); 
				return; 
			case DymeLanguagePackage.EXPR_COMPARACION:
				sequence_ExprComparacion(context, (ExprComparacion) semanticObject); 
				return; 
			case DymeLanguagePackage.EXPR_CONCATENACION:
				sequence_ExprConcatenacion(context, (ExprConcatenacion) semanticObject); 
				return; 
			case DymeLanguagePackage.EXPR_LOGICA:
				sequence_ExprLogica(context, (ExprLogica) semanticObject); 
				return; 
			case DymeLanguagePackage.FUNCION:
				sequence_Funcion(context, (Funcion) semanticObject); 
				return; 
			case DymeLanguagePackage.LLAMADO_FUNC:
				sequence_LlamadoFunc(context, (LlamadoFunc) semanticObject); 
				return; 
			case DymeLanguagePackage.LUNA:
				sequence_Luna(context, (Luna) semanticObject); 
				return; 
			case DymeLanguagePackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case DymeLanguagePackage.PLANETA:
				sequence_Planeta(context, (Planeta) semanticObject); 
				return; 
			case DymeLanguagePackage.POLVO_ESTELAR:
				sequence_PolvoEstelar(context, (PolvoEstelar) semanticObject); 
				return; 
			case DymeLanguagePackage.PROGRAMA:
				sequence_Programa(context, (Programa) semanticObject); 
				return; 
			case DymeLanguagePackage.TIPO:
				if (rule == grammarAccess.getTipoRule()) {
					sequence_Tipo(context, (Tipo) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTipoFuncionOrdenSuperiorRule()) {
					sequence_Tipo_TipoFuncionOrdenSuperior(context, (Tipo) semanticObject); 
					return; 
				}
				else break;
			case DymeLanguagePackage.TIPO_FUNCION_ORDEN_SUPERIOR:
				sequence_TipoFuncionOrdenSuperior(context, (TipoFuncionOrdenSuperior) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns Asignacion
	 *     Asignacion returns Asignacion
	 *
	 * Constraint:
	 *     (name=ID (tipoInferido?='es' tipoClass=TipoFuncionOrdenSuperior)? valorAsig=Expresion)
	 * </pre>
	 */
	protected void sequence_Asignacion(ISerializationContext context, Asignacion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constante returns Constante
	 *     Expresion returns Constante
	 *
	 * Constraint:
	 *     nombre=[Asignacion|ID]
	 * </pre>
	 */
	protected void sequence_Constante(ISerializationContext context, Constante semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.CONSTANTE__NOMBRE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.CONSTANTE__NOMBRE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstanteAccess().getNombreAsignacionIDTerminalRuleCall_0_1(), semanticObject.eGet(DymeLanguagePackage.Literals.CONSTANTE__NOMBRE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expresion returns Constelacion
	 *     ExprConcatenacion returns Constelacion
	 *     Constelacion returns Constelacion
	 *
	 * Constraint:
	 *     x=STRING
	 * </pre>
	 */
	protected void sequence_Constelacion(ISerializationContext context, Constelacion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.EXPR_CONCATENACION__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.EXPR_CONCATENACION__X));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstelacionAccess().getXSTRINGTerminalRuleCall_0(), semanticObject.getX());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EstrellaFugazMeteoro returns EstrellaFugazMeteoro
	 *     Expresion returns EstrellaFugazMeteoro
	 *
	 * Constraint:
	 *     (exprLogCondicion=Expresion estrellaFugazRes=Expresion meteoroRes=Expresion)
	 * </pre>
	 */
	protected void sequence_EstrellaFugazMeteoro(ISerializationContext context, EstrellaFugazMeteoro semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.ESTRELLA_FUGAZ_METEORO__EXPR_LOG_CONDICION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.ESTRELLA_FUGAZ_METEORO__EXPR_LOG_CONDICION));
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.ESTRELLA_FUGAZ_METEORO__ESTRELLA_FUGAZ_RES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.ESTRELLA_FUGAZ_METEORO__ESTRELLA_FUGAZ_RES));
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.ESTRELLA_FUGAZ_METEORO__METEORO_RES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.ESTRELLA_FUGAZ_METEORO__METEORO_RES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEstrellaFugazMeteoroAccess().getExprLogCondicionExpresionParserRuleCall_0_2_0(), semanticObject.getExprLogCondicion());
		feeder.accept(grammarAccess.getEstrellaFugazMeteoroAccess().getEstrellaFugazResExpresionParserRuleCall_0_4_0(), semanticObject.getEstrellaFugazRes());
		feeder.accept(grammarAccess.getEstrellaFugazMeteoroAccess().getMeteoroResExpresionParserRuleCall_1_1_0(), semanticObject.getMeteoroRes());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expresion returns Estrella
	 *     ExprConcatenacion returns Estrella
	 *     Estrella returns Estrella
	 *
	 * Constraint:
	 *     x='a'
	 * </pre>
	 */
	protected void sequence_Estrella(ISerializationContext context, Estrella semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.EXPR_CONCATENACION__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.EXPR_CONCATENACION__X));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEstrellaAccess().getXAKeyword_0(), semanticObject.getX());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expresion returns ExprAritmetica
	 *     ExprAritmetica returns ExprAritmetica
	 *
	 * Constraint:
	 *     ((operadorAr='+' | operadorAr='-' | operadorAr='/' | operadorAr='*' | operadorAr='%') (exprAr+=ExprAritmetica | exprAr+=LlamadoFunc)+)
	 * </pre>
	 */
	protected void sequence_ExprAritmetica(ISerializationContext context, ExprAritmetica semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expresion returns ExprComparacion
	 *     ExprLogica returns ExprComparacion
	 *     ExprComparacion returns ExprComparacion
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             operadorComp='&lt;' | 
	 *             operadorComp='&gt;' | 
	 *             operadorComp='&lt;=' | 
	 *             operadorComp='&gt;=' | 
	 *             operadorComp='==' | 
	 *             operadorComp='~'
	 *         ) 
	 *         exprComIzq=Expresion 
	 *         exprComDer=Expresion
	 *     )
	 * </pre>
	 */
	protected void sequence_ExprComparacion(ISerializationContext context, ExprComparacion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expresion returns ExprConcatenacion
	 *     ExprConcatenacion returns ExprConcatenacion
	 *
	 * Constraint:
	 *     (operadorCon='++' (exprCon+=ExprConcatenacion | exprCon+=LlamadoFunc)+)
	 * </pre>
	 */
	protected void sequence_ExprConcatenacion(ISerializationContext context, ExprConcatenacion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expresion returns ExprLogica
	 *     ExprLogica returns ExprLogica
	 *
	 * Constraint:
	 *     ((operadorLog='&&' | operadorLog='||' | operadorLog='$$' | operadorLog='!') (exprLog+=ExprLogica | exprLog+=LlamadoFunc)+)
	 * </pre>
	 */
	protected void sequence_ExprLogica(ISerializationContext context, ExprLogica semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Funcion returns Funcion
	 *
	 * Constraint:
	 *     (name=ID (param+=Param param+=Param*)? instr+=Instruccion* expr=Expresion (returnTipo?='-&gt;' tipoClass=TipoFuncionOrdenSuperior?)?)
	 * </pre>
	 */
	protected void sequence_Funcion(ISerializationContext context, Funcion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LlamadoFunc returns LlamadoFunc
	 *     Expresion returns LlamadoFunc
	 *
	 * Constraint:
	 *     (funcion=[Funcion|ID] (args+=Expresion args+=Expresion*)?)
	 * </pre>
	 */
	protected void sequence_LlamadoFunc(ISerializationContext context, LlamadoFunc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expresion returns Luna
	 *     ExprLogica returns Luna
	 *     Luna returns Luna
	 *
	 * Constraint:
	 *     (x='LunaNueva' | x='LunaLlena')
	 * </pre>
	 */
	protected void sequence_Luna(ISerializationContext context, Luna semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Param returns Param
	 *
	 * Constraint:
	 *     (name=ID tipoClass=TipoFuncionOrdenSuperior)
	 * </pre>
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.PARAM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.PARAM__NAME));
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.PARAM__TIPO_CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.PARAM__TIPO_CLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParamAccess().getTipoClassTipoFuncionOrdenSuperiorParserRuleCall_2_0(), semanticObject.getTipoClass());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expresion returns Planeta
	 *     ExprAritmetica returns Planeta
	 *     Planeta returns Planeta
	 *
	 * Constraint:
	 *     x=INT
	 * </pre>
	 */
	protected void sequence_Planeta(ISerializationContext context, Planeta semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.PLANETA__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.PLANETA__X));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlanetaAccess().getXINTTerminalRuleCall_0(), semanticObject.getX());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expresion returns PolvoEstelar
	 *     ExprAritmetica returns PolvoEstelar
	 *     PolvoEstelar returns PolvoEstelar
	 *
	 * Constraint:
	 *     x=Double
	 * </pre>
	 */
	protected void sequence_PolvoEstelar(ISerializationContext context, PolvoEstelar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DymeLanguagePackage.Literals.POLVO_ESTELAR__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DymeLanguagePackage.Literals.POLVO_ESTELAR__X));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPolvoEstelarAccess().getXDoubleParserRuleCall_0(), semanticObject.getX());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Programa returns Programa
	 *
	 * Constraint:
	 *     func+=Funcion+
	 * </pre>
	 */
	protected void sequence_Programa(ISerializationContext context, Programa semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TipoFuncionOrdenSuperior returns TipoFuncionOrdenSuperior
	 *
	 * Constraint:
	 *     (
	 *         ordenSuperiorTipo='(' 
	 *         paramFunc+=TipoFuncionOrdenSuperior 
	 *         paramFunc+=TipoFuncionOrdenSuperior* 
	 *         (returnTipoFunc?='-&gt;' (returnFunc=TipoFuncionOrdenSuperior | returnFunc=Tipo))?
	 *     )
	 * </pre>
	 */
	protected void sequence_TipoFuncionOrdenSuperior(ISerializationContext context, TipoFuncionOrdenSuperior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Tipo returns Tipo
	 *
	 * Constraint:
	 *     (tipo='Planeta' | tipo='Constelacion' | tipo='Estrella' | tipo='PolvoEstelar' | tipo='Luna')
	 * </pre>
	 */
	protected void sequence_Tipo(ISerializationContext context, Tipo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TipoFuncionOrdenSuperior returns Tipo
	 *
	 * Constraint:
	 *     (
	 *         (tipo='Planeta' | tipo='Constelacion' | tipo='Estrella' | tipo='PolvoEstelar' | tipo='Luna') 
	 *         (returnTipoFunc?='-&gt;' (returnFunc=TipoFuncionOrdenSuperior | returnFunc=Tipo))?
	 *     )
	 * </pre>
	 */
	protected void sequence_Tipo_TipoFuncionOrdenSuperior(ISerializationContext context, Tipo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
